// Copyright (C) 2024 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package filesystem

import (
	"cmp"
	"fmt"
	"path/filepath"
	"slices"
	"sort"
	"strings"
	"sync/atomic"

	"android/soong/android"
	"android/soong/java"

	"github.com/google/blueprint"
	"github.com/google/blueprint/proptools"
)

var proguardDictToProto = pctx.AndroidStaticRule("proguard_dict_to_proto", blueprint.RuleParams{
	Command:     `${symbols_map} -r8 $in -location $location -write_if_changed $out`,
	Restat:      true,
	CommandDeps: []string{"${symbols_map}"},
}, "location")

type PartitionNameProperties struct {
	// Name of the super partition filesystem module
	Super_partition_name *string
	// Name of the boot partition filesystem module
	Boot_partition_name *string
	// Name of the vendor boot partition filesystem module
	Vendor_boot_partition_name *string
	// Name of the init boot partition filesystem module
	Init_boot_partition_name *string
	// Name of the system partition filesystem module
	System_partition_name *string
	// Name of the system_ext partition filesystem module
	System_ext_partition_name *string
	// Name of the product partition filesystem module
	Product_partition_name *string
	// Name of the vendor partition filesystem module
	Vendor_partition_name *string
	// Name of the odm partition filesystem module
	Odm_partition_name *string
	// Name of the recovery partition filesystem module
	Recovery_partition_name *string
	// The vbmeta partition and its "chained" partitions
	Vbmeta_partitions []string
	// Name of the userdata partition filesystem module
	Userdata_partition_name *string
	// Name of the system_dlkm partition filesystem module
	System_dlkm_partition_name *string
	// Name of the vendor_dlkm partition filesystem module
	Vendor_dlkm_partition_name *string
	// Name of the odm_dlkm partition filesystem module
	Odm_dlkm_partition_name *string
}

type DeviceProperties struct {
	// Path to the prebuilt bootloader that would be copied to PRODUCT_OUT
	Bootloader *string `android:"path"`
	// Path to android-info.txt file containing board specific info.
	Android_info *string `android:"path"`
	// If this is the "main" android_device target for the build, i.e. the one that gets built
	// when running a plain `m` command. Currently, this is the autogenerated android_device module
	// in soong-only builds, but in the future when we check in android_device modules, the main
	// one will be determined based on the lunch product. TODO: Figure out how to make this
	// blueprint:"mutated" and still set it from filesystem_creator
	Main_device *bool

	Ab_ota_updater            *bool
	Ab_ota_partitions         []string
	Ab_ota_keys               []string
	Ab_ota_postinstall_config []string

	Ramdisk_node_list      *string `android:"path"`
	Releasetools_extension *string `android:"path"`
	FastbootInfo           *string `android:"path"`

	Partial_ota_update_partitions []string
	Flash_block_size              *string
	Bootloader_in_update_package  *bool

	// The kernel version in the build. Will be verified against the actual kernel.
	// If not provided, will attempt to extract it from the loose kernel or the kernel inside
	// the boot image. The version is later used to decide whether or not to enable uffd_gc
	// when dexpreopting apps. So setting this doesn't really do anything except enforce that the
	// actual kernel version is as specified here.
	Kernel_version *string
}

type androidDevice struct {
	android.ModuleBase

	partitionProps PartitionNameProperties

	deviceProps DeviceProperties

	allImagesZip android.Path

	proguardDictZip             android.Path
	proguardDictMapping         android.Path
	proguardUsageZip            android.Path
	kernelConfig                android.Path
	kernelVersion               android.Path
	miscInfo                    android.Path
	rootDirForFsConfig          string
	rootDirForFsConfigTimestamp android.Path
	apkCertsInfo                android.Path
	targetFilesZip              android.Path
	updatePackage               android.Path
}

func AndroidDeviceFactory() android.Module {
	module := &androidDevice{}
	module.AddProperties(&module.partitionProps, &module.deviceProps)
	android.InitAndroidMultiTargetsArchModule(module, android.DeviceSupported, android.MultilibFirst)
	return module
}

var numMainAndroidDevicesOnceKey android.OnceKey = android.NewOnceKey("num_auto_generated_anroid_devices")

type partitionDepTagType struct {
	blueprint.BaseDependencyTag
}

type superPartitionDepTagType struct {
	blueprint.BaseDependencyTag
}
type targetFilesMetadataDepTagType struct {
	blueprint.BaseDependencyTag
}

var superPartitionDepTag superPartitionDepTagType
var filesystemDepTag partitionDepTagType
var targetFilesMetadataDepTag targetFilesMetadataDepTagType

func (a *androidDevice) DepsMutator(ctx android.BottomUpMutatorContext) {
	addDependencyIfDefined := func(dep *string) {
		if dep != nil {
			ctx.AddDependency(ctx.Module(), filesystemDepTag, proptools.String(dep))
		}
	}

	if a.partitionProps.Super_partition_name != nil {
		ctx.AddDependency(ctx.Module(), superPartitionDepTag, *a.partitionProps.Super_partition_name)
	}
	addDependencyIfDefined(a.partitionProps.Boot_partition_name)
	addDependencyIfDefined(a.partitionProps.Init_boot_partition_name)
	addDependencyIfDefined(a.partitionProps.Vendor_boot_partition_name)
	addDependencyIfDefined(a.partitionProps.System_partition_name)
	addDependencyIfDefined(a.partitionProps.System_ext_partition_name)
	addDependencyIfDefined(a.partitionProps.Product_partition_name)
	addDependencyIfDefined(a.partitionProps.Vendor_partition_name)
	addDependencyIfDefined(a.partitionProps.Odm_partition_name)
	addDependencyIfDefined(a.partitionProps.Userdata_partition_name)
	addDependencyIfDefined(a.partitionProps.System_dlkm_partition_name)
	addDependencyIfDefined(a.partitionProps.Vendor_dlkm_partition_name)
	addDependencyIfDefined(a.partitionProps.Odm_dlkm_partition_name)
	addDependencyIfDefined(a.partitionProps.Recovery_partition_name)
	for _, vbmetaPartition := range a.partitionProps.Vbmeta_partitions {
		ctx.AddDependency(ctx.Module(), filesystemDepTag, vbmetaPartition)
	}
	a.addDepsForTargetFilesMetadata(ctx)
}

func (a *androidDevice) addDepsForTargetFilesMetadata(ctx android.BottomUpMutatorContext) {
	ctx.AddFarVariationDependencies(ctx.Config().BuildOSTarget.Variations(), targetFilesMetadataDepTag, "liblz4") // host variant
}

func (a *androidDevice) GenerateAndroidBuildActions(ctx android.ModuleContext) {
	if proptools.Bool(a.deviceProps.Main_device) {
		numMainAndroidDevices := ctx.Config().Once(numMainAndroidDevicesOnceKey, func() interface{} {
			return &atomic.Int32{}
		}).(*atomic.Int32)
		total := numMainAndroidDevices.Add(1)
		if total > 1 {
			// There should only be 1 main android_device module. That one will be
			// made the default thing to build in soong-only builds.
			ctx.ModuleErrorf("There cannot be more than 1 main android_device module")
		}
	}

	allInstalledModules := a.allInstalledModules(ctx)

	a.apkCertsInfo = a.buildApkCertsInfo(ctx, allInstalledModules)
	a.kernelVersion, a.kernelConfig = a.extractKernelVersionAndConfigs(ctx)
	a.miscInfo = a.addMiscInfo(ctx)
	a.buildTargetFilesZip(ctx, allInstalledModules)
	a.buildProguardZips(ctx, allInstalledModules)
	a.buildUpdatePackage(ctx)

	var deps []android.Path
	if proptools.String(a.partitionProps.Super_partition_name) != "" {
		superImage := ctx.GetDirectDepProxyWithTag(*a.partitionProps.Super_partition_name, superPartitionDepTag)
		if info, ok := android.OtherModuleProvider(ctx, superImage, SuperImageProvider); ok {
			assertUnset := func(prop *string, propName string) {
				if prop != nil && *prop != "" {
					ctx.PropertyErrorf(propName, "Cannot be set because it's already part of the super image")
				}
			}
			for _, subPartitionType := range android.SortedKeys(info.SubImageInfo) {
				switch subPartitionType {
				case "system":
					assertUnset(a.partitionProps.System_partition_name, "system_partition_name")
				case "system_ext":
					assertUnset(a.partitionProps.System_ext_partition_name, "system_ext_partition_name")
				case "system_dlkm":
					assertUnset(a.partitionProps.System_dlkm_partition_name, "system_dlkm_partition_name")
				case "system_other":
					// TODO
				case "product":
					assertUnset(a.partitionProps.Product_partition_name, "product_partition_name")
				case "vendor":
					assertUnset(a.partitionProps.Vendor_partition_name, "vendor_partition_name")
				case "vendor_dlkm":
					assertUnset(a.partitionProps.Vendor_dlkm_partition_name, "vendor_dlkm_partition_name")
				case "odm":
					assertUnset(a.partitionProps.Odm_partition_name, "odm_partition_name")
				case "odm_dlkm":
					assertUnset(a.partitionProps.Odm_dlkm_partition_name, "odm_dlkm_partition_name")
				default:
					ctx.ModuleErrorf("Unsupported sub-partition of super partition: %q", subPartitionType)
				}
			}

			deps = append(deps, info.SuperImage)
		} else {
			ctx.ModuleErrorf("Expected super image dep to provide SuperImageProvider")
		}
	}
	ctx.VisitDirectDepsProxyWithTag(filesystemDepTag, func(m android.ModuleProxy) {
		imageOutput, ok := android.OtherModuleProvider(ctx, m, android.OutputFilesProvider)
		if !ok {
			ctx.ModuleErrorf("Partition module %s doesn't set OutputfilesProvider", m.Name())
		}
		if len(imageOutput.DefaultOutputFiles) != 1 {
			ctx.ModuleErrorf("Partition module %s should provide exact 1 output file", m.Name())
		}
		deps = append(deps, imageOutput.DefaultOutputFiles[0])
	})

	allImagesZip := android.PathForModuleOut(ctx, "all_images.zip")
	allImagesZipBuilder := android.NewRuleBuilder(pctx, ctx)
	cmd := allImagesZipBuilder.Command().BuiltTool("soong_zip")
	for _, dep := range deps {
		cmd.FlagWithArg("-e ", dep.Base())
		cmd.FlagWithInput("-f ", dep)
	}
	cmd.FlagWithOutput("-o ", allImagesZip)
	allImagesZipBuilder.Build("soong_all_images_zip", "all_images.zip")
	a.allImagesZip = allImagesZip

	allImagesStamp := android.PathForModuleOut(ctx, "all_images_stamp")
	var validations android.Paths
	if !ctx.Config().KatiEnabled() && proptools.Bool(a.deviceProps.Main_device) {
		// In soong-only builds, build this module by default.
		// This is the analogue to this make code:
		// https://cs.android.com/android/platform/superproject/main/+/main:build/make/core/main.mk;l=1396;drc=6595459cdd8164a6008335f6372c9f97b9094060
		ctx.Phony("droidcore-unbundled", allImagesStamp)

		deps = append(deps, a.copyFilesToProductOutForSoongOnly(ctx))
	}

	ctx.Build(pctx, android.BuildParams{
		Rule:        android.Touch,
		Output:      allImagesStamp,
		Implicits:   deps,
		Validations: validations,
	})

	// Checkbuilding it causes soong to make a phony, so you can say `m <module name>`
	ctx.CheckbuildFile(allImagesStamp)

	a.setVbmetaPhonyTargets(ctx)

	a.distFiles(ctx)

	android.SetProvider(ctx, android.AndroidDeviceInfoProvider, android.AndroidDeviceInfo{
		Main_device: android.Bool(a.deviceProps.Main_device),
	})

	if proptools.String(a.partitionProps.Super_partition_name) != "" {
		buildComplianceMetadata(ctx, superPartitionDepTag, filesystemDepTag)
	} else {
		buildComplianceMetadata(ctx, filesystemDepTag)
	}
}

func buildComplianceMetadata(ctx android.ModuleContext, tags ...blueprint.DependencyTag) {
	// Collect metadata from deps
	filesContained := make([]string, 0)
	prebuiltFilesCopied := make([]string, 0)
	platformGeneratedFiles := make([]string, 0)
	for _, tag := range tags {
		ctx.VisitDirectDepsProxyWithTag(tag, func(m android.ModuleProxy) {
			if complianceMetadataInfo, ok := android.OtherModuleProvider(ctx, m, android.ComplianceMetadataProvider); ok {
				filesContained = append(filesContained, complianceMetadataInfo.GetFilesContained()...)
				prebuiltFilesCopied = append(prebuiltFilesCopied, complianceMetadataInfo.GetPrebuiltFilesCopied()...)
				platformGeneratedFiles = append(platformGeneratedFiles, complianceMetadataInfo.GetPlatformGeneratedFiles()...)
			}
		})
	}
	// Merge to module's ComplianceMetadataInfo
	complianceMetadataInfo := ctx.ComplianceMetadataInfo()
	filesContained = append(filesContained, complianceMetadataInfo.GetFilesContained()...)
	sort.Strings(filesContained)
	complianceMetadataInfo.SetFilesContained(filesContained)

	prebuiltFilesCopied = append(prebuiltFilesCopied, complianceMetadataInfo.GetPrebuiltFilesCopied()...)
	sort.Strings(prebuiltFilesCopied)
	complianceMetadataInfo.SetPrebuiltFilesCopied(prebuiltFilesCopied)

	platformGeneratedFiles = append(platformGeneratedFiles, complianceMetadataInfo.GetPlatformGeneratedFiles()...)
	sort.Strings(platformGeneratedFiles)
	complianceMetadataInfo.SetPlatformGeneratedFiles(platformGeneratedFiles)
}

type installedOwnerInfo struct {
	Variation string
	Prebuilt  bool
}

// Returns a list of modules that are installed, which are collected from the dependency
// filesystem and super_image modules.
func (a *androidDevice) allInstalledModules(ctx android.ModuleContext) []android.Module {
	fsInfoMap := a.getFsInfos(ctx)
	allOwners := make(map[string][]installedOwnerInfo)

	for _, partition := range android.SortedKeys(fsInfoMap) {
		fsInfo := fsInfoMap[partition]
		for _, owner := range fsInfo.Owners.ToList() {
			allOwners[owner.Name] = append(allOwners[owner.Name], installedOwnerInfo{
				Variation: owner.Variation,
				Prebuilt:  owner.Prebuilt,
			})
		}
	}

	ret := []android.Module{}
	ctx.WalkDepsProxy(func(mod, _ android.ModuleProxy) bool {
		commonInfo, ok := android.OtherModuleProvider(ctx, mod, android.CommonModuleInfoProvider)
		if !(ok && commonInfo.ExportedToMake) {
			return false
		}
		if variations, ok := allOwners[ctx.OtherModuleName(mod)]; ok &&
			android.InList(installedOwnerInfo{
				Variation: ctx.OtherModuleSubDir(mod),
				Prebuilt:  commonInfo.IsPrebuilt,
			}, variations) {
			ret = append(ret, mod)
		}
		return true
	})

	// Remove duplicates
	ret = android.FirstUniqueInPlace(ret)

	// Sort the modules by their names and variants
	slices.SortFunc(ret, func(a, b android.Module) int {
		return cmp.Compare(a.String(), b.String())
	})
	return ret
}

func insertBeforeExtension(file, insertion string) string {
	ext := filepath.Ext(file)
	return strings.TrimSuffix(file, ext) + insertion + ext
}

func (a *androidDevice) distInstalledFiles(ctx android.ModuleContext) {
	distInstalledFilesJsonAndTxt := func(installedFiles InstalledFilesStruct) {
		if installedFiles.Json != nil {
			ctx.DistForGoal("droidcore-unbundled", installedFiles.Json)
		}
		if installedFiles.Txt != nil {
			ctx.DistForGoal("droidcore-unbundled", installedFiles.Txt)
		}
	}

	fsInfoMap := a.getFsInfos(ctx)
	for _, partition := range android.SortedKeys(fsInfoMap) {
		// installed-files-*{.txt | .json} is not disted for userdata partition
		if partition == "userdata" {
			continue
		}
		fsInfo := fsInfoMap[partition]
		for _, installedFiles := range fsInfo.InstalledFilesDepSet.ToList() {
			distInstalledFilesJsonAndTxt(installedFiles)
		}
	}
}

func (a *androidDevice) distFiles(ctx android.ModuleContext) {
	if !ctx.Config().KatiEnabled() && proptools.Bool(a.deviceProps.Main_device) {
		a.distInstalledFiles(ctx)

		namePrefix := ""
		if ctx.Config().HasDeviceProduct() {
			namePrefix = ctx.Config().DeviceProduct() + "-"
		}
		ctx.DistForGoalWithFilename("droidcore-unbundled", a.proguardDictZip, namePrefix+insertBeforeExtension(a.proguardDictZip.Base(), "-FILE_NAME_TAG_PLACEHOLDER"))
		ctx.DistForGoalWithFilename("droidcore-unbundled", a.proguardDictMapping, namePrefix+insertBeforeExtension(a.proguardDictMapping.Base(), "-FILE_NAME_TAG_PLACEHOLDER"))
		ctx.DistForGoalWithFilename("droidcore-unbundled", a.proguardUsageZip, namePrefix+insertBeforeExtension(a.proguardUsageZip.Base(), "-FILE_NAME_TAG_PLACEHOLDER"))

		if a.deviceProps.Android_info != nil {
			ctx.DistForGoal("droidcore-unbundled", android.PathForModuleSrc(ctx, *a.deviceProps.Android_info))
		}
		if a.miscInfo != nil {
			ctx.DistForGoal("droidcore-unbundled", a.miscInfo)
			if a.partitionProps.Super_partition_name != nil {
				ctx.DistForGoalWithFilename("dist_files", a.miscInfo, "super_misc_info.txt")
			}
		}
		if a.targetFilesZip != nil {
			ctx.DistForGoalWithFilename("target-files-package", a.targetFilesZip, namePrefix+insertBeforeExtension(a.targetFilesZip.Base(), "-FILE_NAME_TAG_PLACEHOLDER"))
		}
		if a.updatePackage != nil {
			ctx.DistForGoalWithFilename("updatepackage", a.updatePackage, namePrefix+insertBeforeExtension(a.updatePackage.Base(), "-FILE_NAME_TAG_PLACEHOLDER"))
		}

	}
}

func (a *androidDevice) MakeVars(_ android.MakeVarsModuleContext) []android.ModuleMakeVarsValue {
	if proptools.Bool(a.deviceProps.Main_device) {
		return []android.ModuleMakeVarsValue{{"SOONG_ONLY_ALL_IMAGES_ZIP", a.allImagesZip.String()}}
	}
	return nil
}

func (a *androidDevice) buildProguardZips(ctx android.ModuleContext, allInstalledModules []android.Module) {
	dictZip := android.PathForModuleOut(ctx, "proguard-dict.zip")
	dictZipBuilder := android.NewRuleBuilder(pctx, ctx)
	dictZipCmd := dictZipBuilder.Command().BuiltTool("soong_zip").Flag("-d").FlagWithOutput("-o ", dictZip)

	dictMapping := android.PathForModuleOut(ctx, "proguard-dict-mapping.textproto")
	dictMappingBuilder := android.NewRuleBuilder(pctx, ctx)
	dictMappingCmd := dictMappingBuilder.Command().BuiltTool("symbols_map").Flag("-merge").Output(dictMapping)

	protosDir := android.PathForModuleOut(ctx, "proguard_mapping_protos")

	usageZip := android.PathForModuleOut(ctx, "proguard-usage.zip")
	usageZipBuilder := android.NewRuleBuilder(pctx, ctx)
	usageZipCmd := usageZipBuilder.Command().BuiltTool("merge_zips").Output(usageZip)

	for _, mod := range allInstalledModules {
		if proguardInfo, ok := android.OtherModuleProvider(ctx, mod, java.ProguardProvider); ok {
			// Maintain these out/target/common paths for backwards compatibility. They may be able
			// to be changed if tools look up file locations from the protobuf, but I'm not
			// exactly sure how that works.
			dictionaryFakePath := fmt.Sprintf("out/target/common/obj/%s/%s_intermediates/proguard_dictionary", proguardInfo.Class, proguardInfo.ModuleName)
			dictZipCmd.FlagWithArg("-e ", dictionaryFakePath)
			dictZipCmd.FlagWithInput("-f ", proguardInfo.ProguardDictionary)
			dictZipCmd.Textf("-e out/target/common/obj/%s/%s_intermediates/classes.jar", proguardInfo.Class, proguardInfo.ModuleName)
			dictZipCmd.FlagWithInput("-f ", proguardInfo.ClassesJar)

			protoFile := protosDir.Join(ctx, filepath.Dir(dictionaryFakePath), "proguard_dictionary.textproto")
			ctx.Build(pctx, android.BuildParams{
				Rule:   proguardDictToProto,
				Input:  proguardInfo.ProguardDictionary,
				Output: protoFile,
				Args: map[string]string{
					"location": dictionaryFakePath,
				},
			})
			dictMappingCmd.Input(protoFile)

			usageZipCmd.Input(proguardInfo.ProguardUsageZip)
		}
	}

	dictZipBuilder.Build("proguard_dict_zip", "Building proguard dictionary zip")
	dictMappingBuilder.Build("proguard_dict_mapping_proto", "Building proguard mapping proto")
	usageZipBuilder.Build("proguard_usage_zip", "Building proguard usage zip")

	a.proguardDictZip = dictZip
	a.proguardDictMapping = dictMapping
	a.proguardUsageZip = usageZip
}

// Helper structs for target_files.zip creation
type targetFilesZipCopy struct {
	srcModule  *string
	destSubdir string
}

type targetFilesystemZipCopy struct {
	fsInfo     FilesystemInfo
	destSubdir string
}

func (a *androidDevice) buildTargetFilesZip(ctx android.ModuleContext, allInstalledModules []android.Module) {
	targetFilesDir := android.PathForModuleOut(ctx, "target_files_dir")
	targetFilesZip := android.PathForModuleOut(ctx, "target_files.zip")

	builder := android.NewRuleBuilder(pctx, ctx)
	builder.Command().Textf("rm -rf %s", targetFilesDir.String())
	builder.Command().Textf("mkdir -p %s", targetFilesDir.String())
	toCopy := []targetFilesZipCopy{
		targetFilesZipCopy{a.partitionProps.System_partition_name, "SYSTEM"},
		targetFilesZipCopy{a.partitionProps.System_ext_partition_name, "SYSTEM_EXT"},
		targetFilesZipCopy{a.partitionProps.Product_partition_name, "PRODUCT"},
		targetFilesZipCopy{a.partitionProps.Vendor_partition_name, "VENDOR"},
		targetFilesZipCopy{a.partitionProps.Odm_partition_name, "ODM"},
		targetFilesZipCopy{a.partitionProps.System_dlkm_partition_name, "SYSTEM_DLKM"},
		targetFilesZipCopy{a.partitionProps.Vendor_dlkm_partition_name, "VENDOR_DLKM"},
		targetFilesZipCopy{a.partitionProps.Odm_dlkm_partition_name, "ODM_DLKM"},
		targetFilesZipCopy{a.partitionProps.Init_boot_partition_name, "BOOT/RAMDISK"},
		targetFilesZipCopy{a.partitionProps.Init_boot_partition_name, "INIT_BOOT/RAMDISK"},
		targetFilesZipCopy{a.partitionProps.Vendor_boot_partition_name, "VENDOR_BOOT/RAMDISK"},
	}

	filesystemsToCopy := []targetFilesystemZipCopy{}
	for _, zipCopy := range toCopy {
		if zipCopy.srcModule == nil {
			continue
		}
		filesystemsToCopy = append(
			filesystemsToCopy,
			targetFilesystemZipCopy{a.getFilesystemInfo(ctx, *zipCopy.srcModule), zipCopy.destSubdir},
		)
	}
	// Get additional filesystems from super_partition dependency
	if a.partitionProps.Super_partition_name != nil {
		superPartition := ctx.GetDirectDepProxyWithTag(*a.partitionProps.Super_partition_name, superPartitionDepTag)
		if info, ok := android.OtherModuleProvider(ctx, superPartition, SuperImageProvider); ok {
			for _, partition := range android.SortedKeys(info.SubImageInfo) {
				filesystemsToCopy = append(
					filesystemsToCopy,
					targetFilesystemZipCopy{info.SubImageInfo[partition], strings.ToUpper(partition)},
				)
			}
		} else {
			ctx.ModuleErrorf("Super partition %s does set SuperImageProvider\n", superPartition.Name())
		}
	}

	for _, toCopy := range filesystemsToCopy {
		rootDirString := toCopy.fsInfo.RootDir.String()
		if toCopy.destSubdir == "SYSTEM" {
			rootDirString = rootDirString + "/system"
		}
		builder.Command().Textf("mkdir -p %s/%s", targetFilesDir.String(), toCopy.destSubdir)
		builder.Command().
			BuiltTool("acp").
			Textf("-rd %s/. %s/%s", rootDirString, targetFilesDir, toCopy.destSubdir).
			Implicit(toCopy.fsInfo.Output) // so that the staging dir is built
		for _, extraRootDir := range toCopy.fsInfo.ExtraRootDirs {
			builder.Command().
				BuiltTool("acp").
				Textf("-rd %s/. %s/%s", extraRootDir, targetFilesDir, toCopy.destSubdir).
				Implicit(toCopy.fsInfo.Output) // so that the staging dir is built
		}

		if toCopy.destSubdir == "SYSTEM" {
			// Create the ROOT partition in target_files.zip
			builder.Command().Textf("rsync --links --exclude=system/* %s/ -r %s/ROOT", toCopy.fsInfo.RootDir, targetFilesDir.String())
			// Add a duplicate rule to assemble the ROOT/ directory in separate intermediates.
			// The output timestamp will be an input to a separate fs_config call.
			a.rootDirForFsConfig = android.PathForModuleOut(ctx, "root_dir_for_fs_config").String()
			rootDirBuilder := android.NewRuleBuilder(pctx, ctx)
			rootDirForFsConfigTimestamp := android.PathForModuleOut(ctx, "root_dir_for_fs_config.timestamp")
			rootDirBuilder.Command().Textf("rsync --links --exclude=system/* %s/ -r %s", toCopy.fsInfo.RootDir, a.rootDirForFsConfig).
				Implicit(toCopy.fsInfo.Output).
				Text("&& touch").
				Output(rootDirForFsConfigTimestamp)
			rootDirBuilder.Build("assemble_root_dir_for_fs_config", "Assemble ROOT/ for fs_config")
			a.rootDirForFsConfigTimestamp = rootDirForFsConfigTimestamp
		}
	}
	// Copy cmdline, kernel etc. files of boot images
	if a.partitionProps.Vendor_boot_partition_name != nil {
		bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(a.partitionProps.Vendor_boot_partition_name), filesystemDepTag)
		bootImgInfo, _ := android.OtherModuleProvider(ctx, bootImg, BootimgInfoProvider)
		builder.Command().Textf("echo %s > %s/VENDOR_BOOT/cmdline", proptools.ShellEscape(strings.Join(bootImgInfo.Cmdline, " ")), targetFilesDir)
		builder.Command().Textf("echo %s > %s/VENDOR_BOOT/vendor_cmdline", proptools.ShellEscape(strings.Join(bootImgInfo.Cmdline, " ")), targetFilesDir)
		if bootImgInfo.Dtb != nil {
			builder.Command().Textf("cp ").Input(bootImgInfo.Dtb).Textf(" %s/VENDOR_BOOT/dtb", targetFilesDir)
		}
		if bootImgInfo.Bootconfig != nil {
			builder.Command().Textf("cp ").Input(bootImgInfo.Bootconfig).Textf(" %s/VENDOR_BOOT/vendor_bootconfig", targetFilesDir)
		}
	}
	if a.partitionProps.Boot_partition_name != nil {
		bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(a.partitionProps.Boot_partition_name), filesystemDepTag)
		bootImgInfo, _ := android.OtherModuleProvider(ctx, bootImg, BootimgInfoProvider)
		builder.Command().Textf("echo %s > %s/BOOT/cmdline", proptools.ShellEscape(strings.Join(bootImgInfo.Cmdline, " ")), targetFilesDir)
		if bootImgInfo.Dtb != nil {
			builder.Command().Textf("cp ").Input(bootImgInfo.Dtb).Textf(" %s/BOOT/dtb", targetFilesDir)
		}
		if bootImgInfo.Kernel != nil {
			builder.Command().Textf("cp ").Input(bootImgInfo.Kernel).Textf(" %s/BOOT/kernel", targetFilesDir)
			// Even though kernel is not used to build vendor_boot, copy the kernel to VENDOR_BOOT to match the behavior of make packaging.
			builder.Command().Textf("cp ").Input(bootImgInfo.Kernel).Textf(" %s/VENDOR_BOOT/kernel", targetFilesDir)
		}
		if bootImgInfo.Bootconfig != nil {
			builder.Command().Textf("cp ").Input(bootImgInfo.Bootconfig).Textf(" %s/BOOT/bootconfig", targetFilesDir)
		}
	}

	if a.deviceProps.Android_info != nil {
		builder.Command().Textf("mkdir -p %s/OTA", targetFilesDir)
		builder.Command().Textf("cp ").Input(android.PathForModuleSrc(ctx, *a.deviceProps.Android_info)).Textf(" %s/OTA/android-info.txt", targetFilesDir)
	}

	a.copyImagesToTargetZip(ctx, builder, targetFilesDir)
	a.copyMetadataToTargetZip(ctx, builder, targetFilesDir, allInstalledModules)

	a.targetFilesZip = targetFilesZip
	builder.Command().
		BuiltTool("soong_zip").
		Text("-d").
		FlagWithOutput("-o ", targetFilesZip).
		FlagWithArg("-C ", targetFilesDir.String()).
		FlagWithArg("-D ", targetFilesDir.String()).
		Text("-sha256")
	builder.Build("target_files_"+ctx.ModuleName(), "Build target_files.zip")
}

func (a *androidDevice) copyImagesToTargetZip(ctx android.ModuleContext, builder *android.RuleBuilder, targetFilesDir android.WritablePath) {
	// Create an IMAGES/ subdirectory
	builder.Command().Textf("mkdir -p %s/IMAGES", targetFilesDir.String())
	if a.deviceProps.Bootloader != nil {
		builder.Command().Textf("cp ").Input(android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.Bootloader))).Textf(" %s/IMAGES/bootloader", targetFilesDir.String())
	}
	// Copy the filesystem ,boot and vbmeta img files to IMAGES/
	ctx.VisitDirectDepsProxyWithTag(filesystemDepTag, func(child android.ModuleProxy) {
		if strings.Contains(child.Name(), "recovery") {
			return // skip recovery.img to match the make packaging behavior
		}
		if info, ok := android.OtherModuleProvider(ctx, child, BootimgInfoProvider); ok {
			// Check Boot img first so that the boot.img is copied and not its dep ramdisk.img
			builder.Command().Textf("cp ").Input(info.Output).Textf(" %s/IMAGES/", targetFilesDir.String())
		} else if info, ok := android.OtherModuleProvider(ctx, child, FilesystemProvider); ok {
			builder.Command().Textf("cp ").Input(info.Output).Textf(" %s/IMAGES/", targetFilesDir.String())
		} else if info, ok := android.OtherModuleProvider(ctx, child, vbmetaPartitionProvider); ok {
			builder.Command().Textf("cp ").Input(info.Output).Textf(" %s/IMAGES/", targetFilesDir.String())
		} else {
			ctx.ModuleErrorf("Module %s does not provide an .img file output for target_files.zip", child.Name())
		}
	})

	if a.partitionProps.Super_partition_name != nil {
		superPartition := ctx.GetDirectDepProxyWithTag(*a.partitionProps.Super_partition_name, superPartitionDepTag)
		if info, ok := android.OtherModuleProvider(ctx, superPartition, SuperImageProvider); ok {
			for _, partition := range android.SortedKeys(info.SubImageInfo) {
				if info.SubImageInfo[partition].OutputHermetic != nil {
					builder.Command().Textf("cp ").Input(info.SubImageInfo[partition].OutputHermetic).Textf(" %s/IMAGES/", targetFilesDir.String())
				}
				if info.SubImageInfo[partition].MapFile != nil {
					builder.Command().Textf("cp ").Input(info.SubImageInfo[partition].MapFile).Textf(" %s/IMAGES/", targetFilesDir.String())
				}
			}
			// super_empty.img
			if info.SuperEmptyImage != nil {
				builder.Command().Textf("cp ").Input(info.SuperEmptyImage).Textf(" %s/IMAGES/", targetFilesDir.String())
			}
		} else {
			ctx.ModuleErrorf("Super partition %s does set SuperImageProvider\n", superPartition.Name())
		}
	}
}

func (a *androidDevice) copyMetadataToTargetZip(ctx android.ModuleContext, builder *android.RuleBuilder, targetFilesDir android.WritablePath, allInstalledModules []android.Module) {
	// Create a META/ subdirectory
	builder.Command().Textf("mkdir -p %s/META", targetFilesDir.String())
	if proptools.Bool(a.deviceProps.Ab_ota_updater) {
		ctx.VisitDirectDepsProxyWithTag(targetFilesMetadataDepTag, func(child android.ModuleProxy) {
			info, _ := android.OtherModuleProvider(ctx, child, android.OutputFilesProvider)
			builder.Command().Textf("cp").Inputs(info.DefaultOutputFiles).Textf(" %s/META/", targetFilesDir.String())
		})
		builder.Command().Textf("cp").Input(android.PathForSource(ctx, "external/zucchini/version_info.h")).Textf(" %s/META/zucchini_config.txt", targetFilesDir.String())
		builder.Command().Textf("cp").Input(android.PathForSource(ctx, "system/update_engine/update_engine.conf")).Textf(" %s/META/update_engine_config.txt", targetFilesDir.String())
		if a.getFsInfos(ctx)["system"].ErofsCompressHints != nil {
			builder.Command().Textf("cp").Input(a.getFsInfos(ctx)["system"].ErofsCompressHints).Textf(" %s/META/erofs_default_compress_hints.txt", targetFilesDir.String())
		}
		// ab_partitions.txt
		abPartitionsSorted := android.SortedUniqueStrings(a.deviceProps.Ab_ota_partitions)
		abPartitionsSortedString := proptools.ShellEscape(strings.Join(abPartitionsSorted, "\\n"))
		builder.Command().Textf("echo -e").Flag(abPartitionsSortedString).Textf(" > %s/META/ab_partitions.txt", targetFilesDir.String())
		// otakeys.txt
		abOtaKeysSorted := android.SortedUniqueStrings(a.deviceProps.Ab_ota_keys)
		abOtaKeysSortedString := proptools.ShellEscape(strings.Join(abOtaKeysSorted, "\\n"))
		builder.Command().Textf("echo -e").Flag(abOtaKeysSortedString).Textf(" > %s/META/otakeys.txt", targetFilesDir.String())
		// postinstall_config.txt
		abOtaPostInstallConfigString := proptools.ShellEscape(strings.Join(a.deviceProps.Ab_ota_postinstall_config, "\\n"))
		builder.Command().Textf("echo -e").Flag(abOtaPostInstallConfigString).Textf(" > %s/META/postinstall_config.txt", targetFilesDir.String())
		// selinuxfc
		if a.getFsInfos(ctx)["system"].SelinuxFc != nil {
			builder.Command().Textf("cp").Input(a.getFsInfos(ctx)["system"].SelinuxFc).Textf(" %s/META/file_contexts.bin", targetFilesDir.String())
		}
	}
	// Copy $partition_filesystem_config.txt
	fsInfos := a.getFsInfos(ctx)
	for _, partition := range android.SortedKeys(fsInfos) {
		if fsInfos[partition].FilesystemConfig == nil {
			continue
		}
		if android.InList(partition, []string{"userdata"}) {
			continue
		}
		if partition != "vendor_ramdisk" {
			// vendor_ramdisk will be handled separately.
			builder.Command().Textf("cp").Input(fsInfos[partition].FilesystemConfig).Textf(" %s/META/%s", targetFilesDir.String(), a.filesystemConfigNameForTargetFiles(partition))
		}
		if partition == "ramdisk" {
			// Create an additional copy at boot_filesystem_config.txt
			builder.Command().Textf("cp").Input(fsInfos[partition].FilesystemConfig).Textf(" %s/META/boot_filesystem_config.txt", targetFilesDir.String())
		}
		if partition == "system" {
			// Create root_filesystem_config from the assembled ROOT/ intermediates directory
			a.generateFilesystemConfigForTargetFiles(ctx, builder, a.rootDirForFsConfigTimestamp, targetFilesDir.String(), a.rootDirForFsConfig, "root_filesystem_config.txt")
		}
		if partition == "vendor_ramdisk" {
			// Create vendor_boot_filesystem_config from the assembled VENDOR_BOOT/RAMDISK intermediates directory
			vendorRamdiskStagingDir := targetFilesDir.String() + "/VENDOR_BOOT/RAMDISK"
			vendorRamdiskFsConfigOut := targetFilesDir.String() + "/META/vendor_boot_filesystem_config.txt"
			fsConfigBin := ctx.Config().HostToolPath(ctx, "fs_config")
			builder.Command().Textf(
				`(cd %s; find . -type d | sed 's,$,/,'; find . \! -type d) | cut -c 3- | sort | sed 's,^,,' | %s -C -D %s -R \"\" > %s`,
				vendorRamdiskStagingDir, fsConfigBin, vendorRamdiskStagingDir, vendorRamdiskFsConfigOut).
				Implicit(fsConfigBin)
		}
	}
	// Copy ramdisk_node_list
	if ramdiskNodeList := android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.Ramdisk_node_list)); ramdiskNodeList != nil {
		builder.Command().Textf("cp").Input(ramdiskNodeList).Textf(" %s/META/", targetFilesDir.String())
	}
	// Copy releasetools.py
	if releaseTools := android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.Releasetools_extension)); releaseTools != nil {
		builder.Command().Textf("cp").Input(releaseTools).Textf(" %s/META/", targetFilesDir.String())
	}
	// apexkeys.txt
	var installedApexKeys []android.Path
	for _, installedModule := range allInstalledModules {
		if info, ok := android.OtherModuleProvider(ctx, installedModule, ApexKeyPathInfoProvider); ok {
			installedApexKeys = append(installedApexKeys, info.ApexKeyPath)
		}
	}
	installedApexKeys = android.SortedUniquePaths(installedApexKeys) // Sort by keypath to match make
	builder.Command().Text("cat").Inputs(installedApexKeys).Textf(" >> %s/META/apexkeys.txt", targetFilesDir.String())
	// apkcerts.txt
	builder.Command().Textf("cp").Input(a.apkCertsInfo).Textf(" %s/META/", targetFilesDir.String())

	// Copy fastboot-info.txt
	if fastbootInfo := android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.FastbootInfo)); fastbootInfo != nil {
		// TODO (b/399788523): Autogenerate fastboot-info.txt if there is no source fastboot-info.txt
		// https://cs.android.com/android/_/android/platform/build/+/80b9546f8f69e78b8fe1870e0e745d70fc18dfcd:core/Makefile;l=5831-5893;drc=077490384423dff9eac954da5c001c6f0be3fa6e;bpv=0;bpt=0
		builder.Command().Textf("cp").Input(fastbootInfo).Textf(" %s/META/fastboot-info.txt", targetFilesDir.String())
	}

	// kernel_configs.txt and kernel_version.txt
	if a.kernelConfig != nil {
		builder.Command().Textf("cp").Input(a.kernelConfig).Textf(" %s/META/", targetFilesDir.String())
	}
	if a.kernelVersion != nil {
		builder.Command().Textf("cp").Input(a.kernelVersion).Textf(" %s/META/", targetFilesDir.String())
	}
	// misc_info.txt
	if a.miscInfo != nil {
		builder.Command().Textf("cp").Input(a.miscInfo).Textf(" %s/META/", targetFilesDir.String())
	}
	// apex_info.pb, care_map.pb, vbmeta_digest.txt
	a.addImgToTargetFiles(ctx, builder, targetFilesDir.String())

	if a.partitionProps.Super_partition_name != nil {
		superPartition := ctx.GetDirectDepProxyWithTag(*a.partitionProps.Super_partition_name, superPartitionDepTag)
		if info, ok := android.OtherModuleProvider(ctx, superPartition, SuperImageProvider); ok {
			// dynamic_partitions_info.txt
			// TODO (b/390192334): Add `building_super_empty_partition=true`
			builder.Command().Text("cp").Input(info.DynamicPartitionsInfo).Textf(" %s/META/", targetFilesDir.String())
		} else {
			ctx.ModuleErrorf("Super partition %s does set SuperImageProvider\n", superPartition.Name())
		}
	}

}

var (
	// https://cs.android.com/android/_/android/platform/build/+/30f05352c3e6f4333c77d4af66c253572d3ea6c9:core/Makefile;l=2111-2120;drc=519f75666431ee2926e0ec8991c682b28a4c9521;bpv=1;bpt=0
	defaultTargetRecoveryFstypeMountOptions = "ext4=max_batch_time=0,commit=1,data=ordered,barrier=1,errors=panic,nodelalloc"
)

// A partial implementation of make's $PRODUCT_OUT/misc_info.txt
// https://cs.android.com/android/platform/superproject/main/+/main:build/make/core/Makefile;l=5894?q=misc_info.txt%20f:build%2Fmake%2Fcore%2FMakefile&ss=android%2Fplatform%2Fsuperproject%2Fmain
// This file is subsequently used by add_img_to_target_files to create additioanl metadata files like apex_info.pb
// TODO (b/399788119): Complete the migration of misc_info.txt
func (a *androidDevice) addMiscInfo(ctx android.ModuleContext) android.Path {
	buildType := func() string {
		if ctx.Config().Debuggable() {
			return "userdebug"
		} else if ctx.Config().Eng() {
			return "eng"
		} else {
			return "user"
		}
	}
	defaultAppCertificate := func() string {
		pem, _ := ctx.Config().DefaultAppCertificate(ctx)
		return strings.TrimSuffix(pem.String(), ".x509.pem")
	}

	builder := android.NewRuleBuilder(pctx, ctx)
	miscInfo := android.PathForModuleOut(ctx, "misc_info.txt")
	builder.Command().
		Textf("rm -f %s", miscInfo).
		Textf("&& echo recovery_api_version=%s >> %s", ctx.Config().VendorConfig("recovery").String("recovery_api_version"), miscInfo).
		Textf("&& echo fstab_version=%s >> %s", ctx.Config().VendorConfig("recovery").String("recovery_fstab_version"), miscInfo).
		Textf("&& echo build_type=%s >> %s", buildType(), miscInfo).
		Textf("&& echo default_system_dev_certificate=%s >> %s", defaultAppCertificate(), miscInfo).
		Textf("&& echo root_dir=%s >> %s", android.PathForModuleInPartitionInstall(ctx, "root"), miscInfo).
		ImplicitOutput(miscInfo)
	if len(ctx.Config().ExtraOtaRecoveryKeys()) > 0 {
		builder.Command().Textf(`echo "extra_recovery_keys=%s" >> %s`, strings.Join(ctx.Config().ExtraOtaRecoveryKeys(), ""), miscInfo)
	} else {
		if a.partitionProps.Boot_partition_name != nil {
			builder.Command().
				Textf("echo mkbootimg_args='--header_version %s' >> %s", a.getBootimgHeaderVersion(ctx, a.partitionProps.Boot_partition_name), miscInfo).
				// TODO: Use boot's header version for recovery for now since cuttlefish does not set `BOARD_RECOVERY_MKBOOTIMG_ARGS`
				Textf(" && echo recovery_mkbootimg_args='--header_version %s' >> %s", a.getBootimgHeaderVersion(ctx, a.partitionProps.Boot_partition_name), miscInfo)
		}
		if a.partitionProps.Init_boot_partition_name != nil {
			builder.Command().
				Textf("echo mkbootimg_init_args='--header_version' %s >> %s", a.getBootimgHeaderVersion(ctx, a.partitionProps.Init_boot_partition_name), miscInfo)
		}
		builder.Command().
			Textf("echo mkbootimg_version_args='--os_version %s --os_patch_level %s' >> %s", ctx.Config().PlatformVersionLastStable(), ctx.Config().PlatformSecurityPatch(), miscInfo).
			Textf(" && echo multistage_support=1 >> %s", miscInfo).
			Textf(" && echo blockimgdiff_versions=3,4 >> %s", miscInfo)
	}
	fsInfos := a.getFsInfos(ctx)
	if _, ok := fsInfos["vendor"]; ok {
		builder.Command().Textf("echo board_uses_vendorimage=true >> %s", miscInfo)
	}
	if fsInfos["system"].ErofsCompressHints != nil {
		builder.Command().Textf("echo erofs_default_compress_hints=%s >> %s", fsInfos["system"].ErofsCompressHints, miscInfo)
	}
	if releaseTools := android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.Releasetools_extension)); releaseTools != nil {
		builder.Command().Textf("echo tool_extensions=%s >> %s", filepath.Dir(releaseTools.String()), miscInfo)
	}
	// ramdisk uses `compressed_cpio` fs_type
	// https://cs.android.com/android/_/android/platform/build/+/30f05352c3e6f4333c77d4af66c253572d3ea6c9:core/Makefile;l=5923-5925;drc=519f75666431ee2926e0ec8991c682b28a4c9521;bpv=1;bpt=0
	if _, ok := fsInfos["ramdisk"]; ok {
		builder.Command().Textf("echo lz4_ramdisks=true >> %s", miscInfo)
	}
	// recovery_mount_options
	// TODO: Add support for TARGET_RECOVERY_FSTYPE_MOUNT_OPTIONS which can be used to override the default
	builder.Command().Textf("echo recovery_mount_options=%s >> %s", defaultTargetRecoveryFstypeMountOptions, miscInfo)

	// vintf information
	if proptools.Bool(ctx.Config().ProductVariables().Enforce_vintf_manifest) {
		builder.Command().Textf("echo vintf_enforce=true >> %s", miscInfo)
	}
	if len(ctx.Config().DeviceManifestFiles()) > 0 {
		builder.Command().Textf("echo vintf_include_empty_vendor_sku=true >> %s", miscInfo)
	}

	if a.partitionProps.Recovery_partition_name == nil {
		builder.Command().Textf("echo no_recovery=true >> %s", miscInfo)
	}
	for _, partition := range android.SortedKeys(fsInfos) {
		if fsInfos[partition].PropFileForMiscInfo != nil {
			builder.Command().Text("cat").Input(fsInfos[partition].PropFileForMiscInfo).Textf(" >> %s", miscInfo)
		}
	}
	if len(a.partitionProps.Vbmeta_partitions) > 0 {
		builder.Command().
			Textf("echo avb_enable=true >> %s", miscInfo).
			Textf("&& echo avb_building_vbmeta_image=true >> %s", miscInfo).
			Textf("&& echo avb_avbtool=avbtool >> %s", miscInfo)

		var allChainedVbmetaPartitionTypes []string
		for _, vbmetaPartitionName := range a.partitionProps.Vbmeta_partitions {
			img := ctx.GetDirectDepProxyWithTag(vbmetaPartitionName, filesystemDepTag)
			if provider, ok := android.OtherModuleProvider(ctx, img, vbmetaPartitionProvider); ok {
				builder.Command().Text("cat").Input(provider.PropFileForMiscInfo).Textf(" >> %s", miscInfo)
				if provider.FilesystemPartitionType != "" { // the top-level vbmeta.img
					allChainedVbmetaPartitionTypes = append(allChainedVbmetaPartitionTypes, provider.FilesystemPartitionType)
				}
			} else {
				ctx.ModuleErrorf("vbmeta dep %s does not set vbmetaPartitionProvider\n", vbmetaPartitionName)
			}
		}
		// Determine the custom vbmeta partitions by removing system and vendor
		customVbmetaPartitionTypes := android.RemoveListFromList(allChainedVbmetaPartitionTypes, []string{"system", "vendor"})
		builder.Command().Textf("echo avb_custom_vbmeta_images_partition_list=%s >> %s",
			strings.Join(android.SortedUniqueStrings(customVbmetaPartitionTypes), " "),
			miscInfo,
		)

	}
	if a.partitionProps.Boot_partition_name != nil {
		builder.Command().Textf("echo boot_images=boot.img >> %s", miscInfo)
	}

	if a.partitionProps.Super_partition_name != nil {
		superPartition := ctx.GetDirectDepProxyWithTag(*a.partitionProps.Super_partition_name, superPartitionDepTag)
		if info, ok := android.OtherModuleProvider(ctx, superPartition, SuperImageProvider); ok {
			// cat dynamic_partition_info.txt
			builder.Command().Text("cat").Input(info.DynamicPartitionsInfo).Textf(" >> %s", miscInfo)
			if info.AbUpdate {
				builder.Command().Textf("echo ab_update=true >> %s", miscInfo)
			}

		} else {
			ctx.ModuleErrorf("Super partition %s does set SuperImageProvider\n", superPartition.Name())
		}
	}
	bootImgNames := []*string{
		a.partitionProps.Boot_partition_name,
		a.partitionProps.Init_boot_partition_name,
		a.partitionProps.Vendor_boot_partition_name,
	}
	for _, bootImgName := range bootImgNames {
		if bootImgName == nil {
			continue
		}

		bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(bootImgName), filesystemDepTag)
		bootImgInfo, _ := android.OtherModuleProvider(ctx, bootImg, BootimgInfoProvider)
		// cat avb_ metadata of the boot images
		builder.Command().Text("cat").Input(bootImgInfo.PropFileForMiscInfo).Textf(" >> %s", miscInfo)
	}

	builder.Command().Textf("echo blocksize=%s >> %s", proptools.String(a.deviceProps.Flash_block_size), miscInfo)
	if proptools.Bool(a.deviceProps.Bootloader_in_update_package) {
		builder.Command().Textf("echo bootloader_in_update_package=true >> %s", miscInfo)
	}
	if len(a.deviceProps.Partial_ota_update_partitions) > 0 {
		builder.Command().Textf("echo partial_ota_update_partitions_list=%s >> %s", strings.Join(a.deviceProps.Partial_ota_update_partitions, " "), miscInfo)
	}

	// Sort and dedup
	builder.Command().Textf("sort -u %s -o %s", miscInfo, miscInfo)

	builder.Build("misc_info", "Building misc_info")

	return miscInfo
}

func (a *androidDevice) getBootimgHeaderVersion(ctx android.ModuleContext, bootImgName *string) string {
	bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(bootImgName), filesystemDepTag)
	bootImgInfo, _ := android.OtherModuleProvider(ctx, bootImg, BootimgInfoProvider)
	return bootImgInfo.HeaderVersion
}

// addImgToTargetFiles invokes `add_img_to_target_files` and creates the following files in META/
// - apex_info.pb
// - care_map.pb
// - vbmeta_digest.txt
func (a *androidDevice) addImgToTargetFiles(ctx android.ModuleContext, builder *android.RuleBuilder, targetFilesDir string) {
	mkbootimg := ctx.Config().HostToolPath(ctx, "mkbootimg")
	builder.Command().
		Textf("PATH=%s:$PATH", ctx.Config().HostToolDir()).
		Textf("MKBOOTIMG=%s", mkbootimg).
		Implicit(mkbootimg).
		BuiltTool("add_img_to_target_files").
		Flag("-a -v -p").
		Flag(ctx.Config().HostToolDir()).
		Text(targetFilesDir)
}

func (a *androidDevice) buildUpdatePackage(ctx android.ModuleContext) {
	var exclusions []string
	fsInfos := a.getFsInfos(ctx)
	// Exclude the partitions that are not supported by flashall
	for _, partition := range android.SortedKeys(fsInfos) {
		if fsInfos[partition].NoFlashall {
			exclusions = append(exclusions, fmt.Sprintf("IMAGES/%s.img", partition))
			exclusions = append(exclusions, fmt.Sprintf("IMAGES/%s.map", partition))
		}
	}

	updatePackage := android.PathForModuleOut(ctx, "img.zip")
	rule := android.NewRuleBuilder(pctx, ctx)

	buildSuperImage := ctx.Config().HostToolPath(ctx, "build_super_image")
	zip2zip := ctx.Config().HostToolPath(ctx, "zip2zip")

	rule.Command().
		BuiltTool("img_from_target_files").
		Text("--additional IMAGES/VerifiedBootParams.textproto:VerifiedBootParams.textproto").
		FlagForEachArg("--exclude ", exclusions).
		FlagWithArg("--build_super_image ", buildSuperImage.String()).
		Implicit(buildSuperImage).
		Implicit(zip2zip).
		Input(a.targetFilesZip).
		Output(updatePackage)

	rule.Build("updatepackage", "Building updatepackage")

	a.updatePackage = updatePackage
}

type ApexKeyPathInfo struct {
	ApexKeyPath android.Path
}

var ApexKeyPathInfoProvider = blueprint.NewProvider[ApexKeyPathInfo]()

func (a *androidDevice) generateFilesystemConfigForTargetFiles(ctx android.ModuleContext, builder *android.RuleBuilder, stagingDirTimestamp android.Path, targetFilesDir, stagingDir, filename string) {
	fsConfigOut := android.PathForModuleOut(ctx, filename)
	ctx.Build(pctx, android.BuildParams{
		Rule:     fsConfigRule,
		Implicit: stagingDirTimestamp,
		Output:   fsConfigOut,
		Args: map[string]string{
			"rootDir": stagingDir,
			"prefix":  "",
		},
	})
	builder.Command().Textf("cp").Input(fsConfigOut).Textf(" %s/META/", targetFilesDir)
}

// Filenames for the partition specific fs_config files.
// Hardcode the ramdisk files to their boot image prefix
func (a *androidDevice) filesystemConfigNameForTargetFiles(partition string) string {
	name := partition + "_filesystem_config.txt"
	if partition == "system" {
		name = "filesystem_config.txt"
	} else if partition == "ramdisk" {
		name = "init_boot_filesystem_config.txt"
	}
	return name
}

func (a *androidDevice) getFilesystemInfo(ctx android.ModuleContext, depName string) FilesystemInfo {
	fsMod := ctx.GetDirectDepProxyWithTag(depName, filesystemDepTag)
	fsInfo, ok := android.OtherModuleProvider(ctx, fsMod, FilesystemProvider)
	if !ok {
		ctx.ModuleErrorf("Expected dependency %s to be a filesystem", depName)
	}
	return fsInfo
}

func (a *androidDevice) setVbmetaPhonyTargets(ctx android.ModuleContext) {
	if !proptools.Bool(a.deviceProps.Main_device) {
		return
	}

	if !ctx.Config().KatiEnabled() {
		for _, vbmetaPartitionName := range a.partitionProps.Vbmeta_partitions {
			img := ctx.GetDirectDepProxyWithTag(vbmetaPartitionName, filesystemDepTag)
			if provider, ok := android.OtherModuleProvider(ctx, img, vbmetaPartitionProvider); ok {
				// make generates `vbmetasystemimage` phony target instead of `vbmeta_systemimage` phony target.
				partitionName := strings.ReplaceAll(provider.Name, "_", "")
				ctx.Phony(fmt.Sprintf("%simage", partitionName), provider.Output)
			}
		}
	}
}

func (a *androidDevice) getKernel(ctx android.ModuleContext) android.Path {
	if a.partitionProps.Boot_partition_name != nil {
		bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(a.partitionProps.Boot_partition_name), filesystemDepTag)
		bootImgInfo, _ := android.OtherModuleProvider(ctx, bootImg, BootimgInfoProvider)
		return bootImgInfo.Kernel
	}
	return nil
}

// Gets the kernel version and configs from the actual kernel file itself. Roughly equivalent to
// this make code: https://cs.android.com/android/platform/superproject/main/+/main:build/make/core/Makefile;l=5443;drc=c0b66fc59de069e06ce0ffd703d4d21613be30c6
// However, it is a simplified version of that make code. Differences include:
//   - Not handling BOARD_KERNEL_CONFIG_FILE because BOARD_KERNEL_CONFIG_FILE was never used.
//   - Not unpacking the bootimage, as we should be able to just always export the kernel directly
//     in the BootimgInfo. We don't currently support prebuilt boot images, but even if we add that
//     in the future, it can be done in a prebuilt_bootimage module type that still exports the same
//     BootimgInfo.
//   - We don't print a warning and output '<unknown-kernel>' to kernel_version_for_uffd_gc.txt
//     because we expect the kernel to always be present. If it's not, we will get an error that
//     kernel_version_for_uffd_gc.txt doesn't exist. This may require later tweaking to the
//     dexpreopt rules so that they don't attempt to access that file in builds that don't have
//     a kernel.
func (a *androidDevice) extractKernelVersionAndConfigs(ctx android.ModuleContext) (android.Path, android.Path) {
	kernel := a.getKernel(ctx)
	// If there's no kernel, don't create kernel version / kernel config files. Reverse dependencies
	// on those files have to account for this, for example by disabling dexpreopt in unbundled
	// builds.
	if kernel == nil {
		return nil, nil
	}

	lz4tool := ctx.Config().HostToolPath(ctx, "lz4")

	extractedVersionFile := android.PathForModuleOut(ctx, "kernel_version.txt")
	extractedConfigsFile := android.PathForModuleOut(ctx, "kernel_configs.txt")
	builder := android.NewRuleBuilder(pctx, ctx)
	builder.Command().BuiltTool("extract_kernel").
		Flag("--tools lz4:"+lz4tool.String()).Implicit(lz4tool).
		FlagWithInput("--input ", kernel).
		FlagWithOutput("--output-release ", extractedVersionFile).
		FlagWithOutput("--output-configs ", extractedConfigsFile).
		Textf(`&& printf "\n" >> %s`, extractedVersionFile)

	if specifiedVersion := proptools.String(a.deviceProps.Kernel_version); specifiedVersion != "" {
		specifiedVersionFile := android.PathForModuleOut(ctx, "specified_kernel_version.txt")
		android.WriteFileRule(ctx, specifiedVersionFile, specifiedVersion)
		builder.Command().Text("diff -q").
			Input(specifiedVersionFile).
			Input(extractedVersionFile).
			Textf(`|| (echo "Specified kernel version '$(cat %s)' does not match actual kernel version '$(cat %s)'"; exit 1)`, specifiedVersionFile, extractedVersionFile)
	}

	builder.Build("extract_kernel_info", "Extract kernel version and configs")

	if proptools.Bool(a.deviceProps.Main_device) && !ctx.Config().KatiEnabled() {
		if ctx.Config().EnableUffdGc() == "default" {
			kernelVersionFile := android.PathForOutput(ctx, "dexpreopt/kernel_version_for_uffd_gc.txt")
			ctx.Build(pctx, android.BuildParams{
				Rule:   android.CpIfChanged,
				Input:  extractedVersionFile,
				Output: kernelVersionFile,
			})
		}

		ctx.DistForGoal("droid_targets", extractedVersionFile)
	}

	return extractedVersionFile, extractedConfigsFile
}

func (a *androidDevice) buildApkCertsInfo(ctx android.ModuleContext, allInstalledModules []android.Module) android.Path {
	// TODO (spandandas): Add compressed
	formatLine := func(cert java.Certificate, name, partition string) string {
		pem := cert.AndroidMkString()
		var key string
		if cert.Key == nil {
			key = ""
		} else {
			key = cert.Key.String()
		}
		return fmt.Sprintf(`name="%s" certificate="%s" private_key="%s" partition="%s"`, name, pem, key, partition)
	}

	apkCerts := []string{}
	var apkCertsFiles android.Paths
	for _, installedModule := range allInstalledModules {
		partition := ""
		if commonInfo, ok := android.OtherModuleProvider(ctx, installedModule, android.CommonModuleInfoProvider); ok {
			partition = commonInfo.PartitionTag
		} else {
			ctx.ModuleErrorf("%s does not set CommonModuleInfoKey", installedModule.Name())
		}
		if info, ok := android.OtherModuleProvider(ctx, installedModule, java.AppInfoProvider); ok {
			if info.AppSet {
				apkCertsFiles = append(apkCertsFiles, info.ApkCertsFile)
			} else {
				apkCerts = append(apkCerts, formatLine(info.Certificate, info.InstallApkName+".apk", partition))
			}
		} else if info, ok := android.OtherModuleProvider(ctx, installedModule, java.AppInfosProvider); ok {
			for _, certInfo := range info {
				// Partition information of apk-in-apex is not exported to the legacy Make packaging system.
				// Hardcode the partition to "system"
				apkCerts = append(apkCerts, formatLine(certInfo.Certificate, certInfo.InstallApkName+".apk", "system"))
			}
		} else if info, ok := android.OtherModuleProvider(ctx, installedModule, java.RuntimeResourceOverlayInfoProvider); ok {
			apkCerts = append(apkCerts, formatLine(info.Certificate, info.OutputFile.Base(), partition))
		}
	}
	slices.Sort(apkCerts) // sort by name
	fsInfos := a.getFsInfos(ctx)
	if fsInfos["system"].HasFsverity {
		defaultPem, defaultKey := ctx.Config().DefaultAppCertificate(ctx)
		apkCerts = append(apkCerts, formatLine(java.Certificate{Pem: defaultPem, Key: defaultKey}, "BuildManifest.apk", "system"))
		if info, ok := fsInfos["system_ext"]; ok && info.HasFsverity {
			apkCerts = append(apkCerts, formatLine(java.Certificate{Pem: defaultPem, Key: defaultKey}, "BuildManifestSystemExt.apk", "system_ext"))
		}
	}

	apkCertsInfoWithoutAppSets := android.PathForModuleOut(ctx, "apkcerts_without_app_sets.txt")
	android.WriteFileRuleVerbatim(ctx, apkCertsInfoWithoutAppSets, strings.Join(apkCerts, "\n")+"\n")
	apkCertsInfo := android.PathForModuleOut(ctx, "apkcerts.txt")
	ctx.Build(pctx, android.BuildParams{
		Rule:        android.CatAndSort,
		Description: "combine apkcerts.txt",
		Output:      apkCertsInfo,
		Inputs:      append(apkCertsFiles, apkCertsInfoWithoutAppSets),
	})
	return apkCertsInfo
}
